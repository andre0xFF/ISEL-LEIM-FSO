package robot.states;

import java.util.ArrayList;
import java.util.List;
import robot.MyRobotLego;

public abstract class Scanner extends Thread 
{
	protected final MyRobotLego robot;
	
	/* Scanner related variables, gets and sets */
	public final static int DEFAULT_DELAY = 500;
	
	protected int delay = DEFAULT_DELAY;													// How much time (ms) the scanner sleeps between each scan	
	protected boolean active = true;														// Determines if a scanner is active or not
	protected final int id;																	// Scanner identification
	protected final int port;																// Scanner port
	
	public int getDelay() { return this.delay; }
	public void setDelay(int delay) { this.delay = delay; }
	public boolean isActive() { return this.active; }
	public void deactivate() { this.active = false; }
	public int getPort() { return this.port; }
	
	protected abstract void setPort(int port);
	public abstract int scan();

	/* Who will listen to scanner's events */
	protected List<RobotNervousSystem> listeners = new ArrayList<RobotNervousSystem>();		// Objects listening to scanners events
	protected void addListener(RobotNervousSystem toAdd) { this.listeners.add(toAdd); }		// Add an object that wants to listen to events
	
	/* What each scanner will report */
	protected abstract void objectDetected();												// Event triggered when an object is detected
	
	protected void objectIsGone() {															// Event triggered when an object is no longer detected
		objectDetected = false;
		for(RobotNervousSystem listener : listeners)  {
			listener.ObjectIsGone();	
		}
	}													
	
	/* Scanner's event triggers */
	protected int objectDistance = 0;														// Object's distance reported by scan()
	protected boolean objectDetected = false;
	
	public Scanner(StateMachine machine, int id, int port) {
		this.robot = machine.getRobot();
		this.id = id;
		setPort(port);
		this.port = port;
		this.addListener(machine);
		this.start();
	}
	
	@Override
	public void run() {		
		if(!active) { this.interrupt(); }
		
		objectDistance = scan();
	}
}

interface RobotNervousSystem {																// Interface to be implemented that defines the events generated by a scanner
	void ObjectDetected(ActiveState state);
	void ObjectIsGone();
}

class BackScanner extends Scanner {
	public static final int ID = 1;
	
	private int[] trigger = new int[2];
	private int objectDistance = 0;

	public BackScanner(StateMachine machine, int id, int port) {
		super(machine, id, port);
	}

	@Override
	protected void objectDetected() {
		objectDetected = true;
		for(RobotNervousSystem listener : listeners)  {
			listener.ObjectDetected(new Escape(robot, this, trigger));	
		}
	}

	@Override
	protected void setPort(int port) { robot.SetSensorLowspeed(port); }

	@Override
	public int scan() { return robot.SensorUS(port); }
	
	@Override
	public void run() { 
		while(active) {
			super.run();
			
			if(!objectDetected && (objectDistance > trigger[0] && objectDistance < trigger[1])) {
				objectDetected();
			}			
			else if(objectDetected && (objectDistance < trigger[0] || objectDistance > trigger[1])) {
				objectIsGone();
			}
						
			try { Thread.sleep(delay); } 
			catch (InterruptedException e) { }
		}
	}

}

class FrontScanner extends Scanner {
	public static final int ID = 2;
	
	public FrontScanner(StateMachine machine, int id, int port) {
		super(machine, id, port);
	}

	@Override
	protected void objectDetected() {
		objectDetected = true;
		for(RobotNervousSystem listener : listeners)  {
			listener.ObjectDetected(new Avoid(robot, this));	
		}
	}

	@Override
	protected void setPort(int port) { robot.SetSensorTouch(port); }

	@Override
	public int scan() { return robot.Sensor(port); }
	
	@Override
	public void run() {
		while(active) {
			super.run();
			
			if(!objectDetected && objectDistance == 1) { objectDetected(); }
			else if(objectDetected && objectDistance != 1) { objectIsGone(); }
			
			try { Thread.sleep(delay); } 
			catch (InterruptedException e) { }
		}
	}
	
}
